stages:
  - trigger

trigger_lambdatest_hyperexecute:
  stage: trigger
  image: alpine:3.20
  before_script:
    - apk add --no-cache curl jq
  script:
    # 1) Build JSON payload (VALID JSON - no comments)
    - |
      jq -n \
        --arg test_run_id "$TEST_RUN_ID" \
        --arg title "${CI_PROJECT_NAME}-${CI_COMMIT_REF_NAME}-${CI_PIPELINE_ID}" \
        --arg region "${LT_REGION:-centralindia}" \
        --arg mobile_region "${LT_MOBILE_REGION:-ap}" \
        '{
          test_run_id: $test_run_id,
          concurrency: 1,
          title: $title,
          console_log: false,
          network_logs: false,
          network_full_har: false,
          region: $region,
          mobile_region: $mobile_region,
          retry_on_failure: true,
          max_retries: 1
        }' > payload.json

    # 2) Call LambdaTest API and capture response + status code
    - |
      echo "Triggering LambdaTest HyperExecute run..."
      http_code=$(curl -sS -o response.json -w "%{http_code}" \
        --location "https://test-manager-api.lambdatest.com/api/atm/v1/hyperexecute" \
        -H "Content-Type: application/json" \
        -H "Authorization: Basic ${LT_TM_BASE64_AUTH}" \
        --data @payload.json)

      echo "HTTP Status: $http_code"
      cat response.json | jq .

      # 3) Fail pipeline if trigger API didn't succeed
      if [ "$http_code" -lt 200 ] || [ "$http_code" -ge 300 ]; then
        echo "ERROR: Failed to trigger LambdaTest run"
        exit 1
      fi

    # 4) Extract an id (best-effort; depends on API response fields)
    - |
      RUN_ID=$(jq -r '.run_id // .id // .build_id // empty' response.json)
      echo "RUN_ID=$RUN_ID" | tee lt.env
      echo "Triggered RUN_ID=$RUN_ID"

  artifacts:
    when: always
    paths:
      - payload.json
      - response.json
    reports:
      dotenv: lt.env
    expire_in: 7 days

  # Optional: make it manual so you click-to-run
  when: manual
